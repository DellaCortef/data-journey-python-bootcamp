# Lesson 19: Making our API

## What is FastAPI?

FastAPI is a high-performance web framework for building APIs with Python 3.6+ based on declarative data types (thanks to Pydantic) and the ASGI (Asynchronous Server Gateway Interface) standard. It is designed to be easy to use, quick to learn, and highly performance-efficient, offering native support for Python data types, data typing, automatic input validation, and automatic interactive documentation (automatically generated by Swagger UI and ReDoc).

Main features:

1. **Fast**: Uses asynchronous Python and optimization techniques for high performance.
2. **Easy to use**: It has a declarative and intuitive syntax, allowing rapid prototyping.
3. **Data Typing**: Uses Python data typing to ensure data security and consistency.
4. **Automatic documentation**: Automatically generates interactive documentation for your API.
5. **Support for OpenAPI and Swagger**: Full compatibility with these standards, allowing integration with other tools.

## Examples of using FastAPI:

### 1. Creating a basic API:

```python
from typing import Union

from fastapi import FastAPI

app = FastAPI()


@app.get("/")
def read_root():
    return {"Hello": "World"}


@app.get("/items/{item_id}")
def read_item(item_id: int, q: Union[str, None] = None):
    return {"item_id": item_id, "q": q}
```

### 2. Defining data models with Pydantic:

```python
from typing import Union

from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()


class Item(BaseModel):
    name: str
    price: float
    is_offer: Union[bool, None] = None


@app.get("/")
def read_root():
    return {"Hello": "World"}


@app.get("/items/{item_id}")
def read_item(item_id: int, q: Union[str, None] = None):
    return {"item_id": item_id, "q": q}


@app.put("/items/{item_id}")
def update_item(item_id: int, item: Item):
    return {"item_name": item.name, "item_id": item_id}
```

### Challenge

Create our first CRUD

1. **`POST /items/`: Creates a new item**
    
    This route allows you to create a new item in the database. The client sends the new item data in the body of the HTTP request, and the server adds this item to the database. Here's how it works:
    
    * **HTTP Verb**: POST
    * **Endpoint**: `/items/`
    * **Action**: Creates a new item in the database.
    * **Requirements**: The request body must contain the new item data.
    * **Response**: Returns the new item created.
2. **`GET /items/`: Returns a paginated list of items**
    
    This route allows you to retrieve a paginated list of items from the database. The client can optionally specify the `skip` (how many items to skip) and `limit` (how many items to return) parameters for pagination. Here's how it works:
    
    * **HTTP Verb**: GET
    * **Endpoint**: `/items/`
    * **Action**: Returns a paginated list of database items.
    * **Query parameters**: `skip` (optional, default = 0) and `limit` (optional, default = 10).
    * **Response**: Returns a list of items as specified by the query parameters.
3. **`GET /items/{item_id}`: Returns a specific item based on ID**
    
    This route allows you to retrieve a specific item from the database based on the ID provided. Here's how it works:
    
    * **HTTP Verb**: GET
    * **Endpoint**: `/items/{item_id}`
    * **Action**: Returns a specific item based on the given ID.
    * **Path parameters**: `item_id` (ID of the item to be retrieved).
    * **Response**: Returns the item corresponding to the given ID.
4. **`PUT /items/{item_id}`: Updates an existing item based on ID**
    
    This route allows you to update the data of an existing item in the database based on the provided ID. The client sends the new item data in the body of the HTTP request. Here's how it works:
    
    * **HTTP Verb**: PUT
    * **Endpoint**: `/items/{item_id}`
    * **Action**: Updates an existing item based on the provided ID.
    * **Path parameters**: `item_id` (ID of the item to be updated).
    * **Requirements**: The request body must contain the new item data.
    * **Response**: Returns the updated item.
5. **`DELETE /items/{item_id}`: Deletes an existing item based on ID**
    This route allows you to delete an existing item in the database based on the ID provided. Here's how it works:
    
    * **HTTP verb**: DELETE
    * **Endpoint**: `/items/{item_id}`
    * **Action**: Deletes an existing item based on the provided ID.
    * **Path parameters**: `item_id` (ID of the item to be deleted).
    * **Response**: Returns the deleted item.

These operations provide a complete API for managing items in the database, allowing you to create, retrieve, update, and delete items efficiently and securely. Ensure that operations meet your project requirements and that you implement the necessary logic to ensure data consistency and security.